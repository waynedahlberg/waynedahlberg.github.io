import { waynedahlberg } from "@/authors";

export const meta = {
  title: `Swift Types`,
  description: `Back to basics with Swift types`,
  date: "2020-11-07T12:00:00.000Z",
  authors: [waynedahlberg],
  discussion: "https://github.com/tailwindlabs/tailwindcss/discussions/2511",
};

**Note:** _This is the first of several articles intended as personal growth exercises, rather than sharing with the community. As I learn new things, I want to write about them to further cement my understanding and hold myself accountable._

In the Swift programming language, nearly everything is based on a _named type_ or a _compound type_.

<!--more-->

Named types can be assigned names when created. These include **classes**, **structures**, **enumerations**, and **protocols**. Instances of user-defined named types carry the name of the given type. For example, a class named `MyClass` will have the type `MyClass`. Swift also includes many standard named types for arrays, dictionaries and optional values.

Compound types are types without a specific name. A compound type may contain other named and compound types. For example, the compound tuple type `(Int, (Int, Int))` contains two inner types. The first is the named `Int` type, the second is a compount type of `(Int, Int)`.

Properties are either stored, or computed. A stored property has a fixed value. On the other hand, a computed property is calculated every time it is are accessed. There are also simple observers on properties that listen to changes via callbacks. These observers are `willSet` and `didSet`.

This was very difficult for me to wrap my head around in my early Swift learning days.

### Value types vs Reference types

When a piece of data is saved to disk, it is saved in a container. Imagine each container having a label on the outside. Value types refer to the _actual data_ inside the container. Reference types refer to the label, or _memory address_ on the container.

```Swift
class SimpleClass {
	var name = ""
}

struct SimpleStruct {
	var name = ""
}

// Memory address is constant but data is variable
let simpleClass = SimpleClass()
simpleClass.name = "wayne" // OK

// Data is constant but address is variable
let simpleStruct = SimpleStruct()
simpleStruct.name = "wayne" // Compiler error
```

So here we have a constant (let) _class_ instance with a constant memory address, but its data is variable and can change at any time. This was a huge eye opener for me to learn early on.

However, a constant (let) _structure_ instance has constant data, but a variable memory address. It will throw a compiler error every time the constant structure is changed.

Convention tells us to use `struct` primarily, but should opt for `class` when our code is designed for instances, as well as interfacing with legacy Objective-C code.

### Computed Properties â€” Getters & Setters

Computed properties have special functions for getting and setting of property values. It's value is determined by the getter function every time it's accessed, instead of some stored property with a specific value.

Getter functions can retrieve data from storage and setter functions can assign the data to storage directly.

```Swift
var randomInteger: Int {
  get {
    return 100 * Int.random(in: 0...10)
  }
}
```

Setter functions are optional in computed properties. When no setter function is defined, it's treated as a normal stored, read-only property.

### Summary

- Reference type instance points to the memory address, not the data
- Value type instance points to the data but not the memory address
- Getter and setter functions are called when computed properties are accessed or modified.
