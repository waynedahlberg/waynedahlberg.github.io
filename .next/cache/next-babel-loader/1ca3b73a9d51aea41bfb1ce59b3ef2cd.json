{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport Post from \"@/components/Post\";\nimport { waynedahlberg } from \"@/authors\";\nexport { getStaticProps } from \"@/getStaticProps\";\nexport const meta = {\n  title: `Swift Types`,\n  description: `Back to basics with Swift types`,\n  date: \"2020-11-07T12:00:00.000Z\",\n  authors: [waynedahlberg],\n  discussion: \"https://github.com/tailwindlabs/tailwindcss/discussions/2511\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", props);\n};\n\nconst layoutProps = {\n  meta\n};\n\nconst MDXLayout = props => mdx(Post, _extends({\n  meta: meta\n}, props));\n\nexport default function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, `In the Swift programming language, nearly everything is based on a named type or compound type. Named types can be assigned names when created. These include `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `classes`), `, `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `structures`), `, `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `enumerations`), `, and `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `protocols`), `. Instances of user-defined named types carry the name of the given type. For example, a class named `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `MyClass`), ` will have the type `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `MyClass`), `. Swift also includes many standard named types for arrays, dictionaries and optional values.`), mdx(\"div\", {\n    class: \"rounded-md bg-blue-50 p-4\"\n  }, mdx(\"div\", {\n    class: \"flex\"\n  }, mdx(\"div\", {\n    class: \"flex-shrink-0\"\n  }, mdx(\"svg\", {\n    class: \"h-5 w-5 text-blue-400\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 20 20\",\n    fill: \"currentColor\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\",\n    clipRule: \"evenodd\"\n  }))), mdx(\"div\", {\n    class: \"ml-3 flex-1 md:flex md:justify-between\"\n  }, mdx(\"p\", {\n    class: \"text-sm leading-5 text-blue-700\"\n  }, \"This is a another post in a series intended as a personal growth exercise. As I learn and digest new things, I want to write about them to solidify my understanding.\"), mdx(\"p\", {\n    class: \"mt-3 text-sm leading-5 md:mt-0 md:ml-6\"\n  }, mdx(\"a\", {\n    href: \"https://fs.blog/2015/01/richard-feynman-knowing-something/\",\n    class: \"whitespace-no-wrap font-medium text-blue-700 hover:text-blue-600 transition ease-in-out duration-150\"\n  }, \"Feynman \\u2192\"))))), mdx(\"p\", null, `Compound types are types without a specific name. A compound type may contain other named and compound types. For example, the compound tuple type `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `(Int, (Int, Int))`), ` contains two inner types. The first is the named `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Int`), ` type, the second is a compount type of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `(Int, Int)`), `.`), mdx(\"p\", null, `Properties are either stored, or computed. A stored property has a fixed value. On the other hand, a computed property is calculated every time it is are accessed. There are also simple observers on properties that listen to changes via callbacks. These observers are `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `willSet`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `didSet`), `.`), mdx(\"p\", null, `This was very difficult for me to wrap my head around in my early Swift learning days.`), mdx(\"h3\", null, `Value types vs Reference types`), mdx(\"p\", null, `When a piece of data is saved to disk, it is saved in a container. Imagine each container having a label on the outside. Value types refer to the `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `actual data`), ` inside the container. Reference types refer to the label, or `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `memory address`), ` on the container.`), mdx(\"pre\", {\n    \"className\": \"language-swift\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-Swift\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `class`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `SimpleClass`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `{`), `\n    `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `var`), ` name `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `=`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-green\"\n  }), `\"\"`), `\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `}`), `\n\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `struct`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `SimpleStruct`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `{`), `\n    `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `var`), ` name `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `=`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-green\"\n  }), `\"\"`), `\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `}`), `\n\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-gray-400 italic\"\n  }), `// Memory address is constant but data is variable`), `\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `let`), ` simpleClass `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `=`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-blue\"\n  }), `SimpleClass`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `(`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `)`), `\nsimpleClass`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `.`), `name `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `=`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-green\"\n  }), `\"wayne\"`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-gray-400 italic\"\n  }), `// OK`), `\n\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-gray-400 italic\"\n  }), `// Data is constant but address is variable`), `\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `let`), ` simpleStruct `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `=`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-blue\"\n  }), `SimpleStruct`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `(`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `)`), `\nsimpleStruct`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `.`), `name `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `=`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-green\"\n  }), `\"wayne\"`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-gray-400 italic\"\n  }), `// Compiler error`), `\n`)), mdx(\"p\", null, `So here we have a constant (let) `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `class`), ` instance with a constant memory address, but its data is variable and can change at any time. This was a huge eye opener for me to learn early on.`), mdx(\"p\", null, `However, a constant (let) `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `structure`), ` instance has constant data, but a variable memory address. It will throw a compiler error every time the constant structure is changed.`), mdx(\"p\", null, `Convention tells us to use `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `struct`), ` primarily, but should opt for `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `class`), ` when our code is designed for instances, as well as interfacing with legacy Objective-C code.`), mdx(\"h3\", null, `Computed Properties — Getters & Setters`), mdx(\"p\", null, `Computed properties have special functions for getting and setting of property values. It's value is determined by the getter function every time it's accessed, instead of some stored property with a specific value.`), mdx(\"p\", null, `Getter functions can retrieve data from storage and setter functions can assign the data to storage directly.`), mdx(\"pre\", {\n    \"className\": \"language-swift\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-Swift\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `var`), ` randomInteger`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `:`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `Int`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `{`), `\n  `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `get`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `{`), `\n    `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `return`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `100`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `*`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `Int`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `.`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-blue\"\n  }), `random`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `(`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-purple\"\n  }), `in`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `:`), ` `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `0`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `.`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `.`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `.`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"\"\n  }), `10`), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `)`), `\n  `, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `}`), `\n`, mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"text-code-white\"\n  }), `}`), `\n`)), mdx(\"p\", null, `Setter functions are optional in computed properties. When no setter function is defined, it's treated as a normal stored, read-only property.`), mdx(\"h3\", null, `Summary`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Reference type instance points to the memory address, not the data`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Value type instance points to the data but not the memory address`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Getter and setter functions are called when computed properties are accessed or modified.`)), mdx(\"h3\", null, `Resources:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://fluffy.es/reference-vs-value-type/\"\n  }), `Understanding Reference and Value types`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes\"\n  }), `Choosing Between Structures and Classes`))));\n}\n;\nMDXContent.isMDXComponent = true;","map":null,"metadata":{},"sourceType":"module"}